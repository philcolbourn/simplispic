"Loading a Toy Scheme Library..."

(define pc-scheme.sim #t)

;; some necessary symbols

;; alias primitives with nicer names
;(define + iadd)
(define + (lambda args
  (if (null? args) 0 (iadd (car args) (apply + (cdr args))  ))  ))

;(define - isub)
(define - (lambda args
  (if (null? args) 0 (isub (car args) (apply + (cdr args))  ))  ))

(define * imul)
; FIXME: do same for * and / etc.
(define / idiv)
(define remainder imod)
(define modulo imod)
(define % imod)
;(define eq? eqp)
;(define equal? equalp)
;(define list? listp)  ; FIXME: can list? be written here?
;(define < ilt)
;(define > igt)
;(define <= ilte)
;(define >= igte)
;(define = ieq)
;(define print printa)
;(define procedure? procp)  ; FIXME: a procedure is also a pair
;(define exit exita)
;(define set-car! set_car)
;(define set-cdr! set_cdr)
; FIXME: do set!
;(define symbol->string sym_to_str)
;(define string->symbol str_to_sym)
;(define string-ref str_ref)
(define symbol-ref string-ref)
;(define string-length string_length)
(define symbol-length string-length)

;(define get-type-tag get_type_tag)
;(define type get_type_tag)

(define STRING   (type "a string"))
(define CHAR     (type #\a)       )
(define PAIR     (type '(a apair)))
(define NUMBER   (type 1)         )
(define SYMBOL   (type 'aSymbol)  )
(define CONSTANT (type #t)        )

;(define symbol? symbolp)
(define symbol? (lambda (s) (eq? (type s) SYMBOL)))

;(define constant? constantp)
(define constant? (lambda (c) (eq? (type c) CONSTANT)))
(constant? #t)
(constant? #f)
(constant? '())
;.
(exit 1)

;(define string? stringp)
(define string? (lambda (s) (eq? (type s) STRING)))

;(define char? charp)
(define char? (lambda (c) (eq? (type c) CHAR)))

;(define pair? pairp)
(define pair? (lambda (p) (eq? (type p) PAIR)))

;(define number? numberp)
(define number? (lambda (n) (eq? (type n) NUMBER)))

;(define null? nullp)
(define null? (lambda (a) (eq? a '())))

;(define atom? atomp)
(define atom? (lambda (a)
  (if (null? a) #t
  (if (symbol? a) #t
  (if (constant? a) #t
  (if (number? a) #t
  (if (string? a) #t
      (char? a)  )))))  ))
                  
(define boolean? (lambda (b)
  (if (eq? b #t) #t (eq? b #f)) ))

(define false? (lambda (b) (eq? b #f)))
(define true? (lambda (b) (not (false b))))

(define caar (lambda (a) (car (car a))) )
(define cadr (lambda (a) (car (cdr a))) )
(define cdar (lambda (a) (cdr (car a))) )
(define cddr (lambda (a) (cdr (cdr a))) )

(define caaar (lambda (a) (car (car (car a)))) )
(define caadr (lambda (a) (car (car (cdr a)))) )
(define cadar (lambda (a) (car (cdr (car a)))) )
(define caddr (lambda (a) (car (cdr (cdr a)))) )

(define cdaar (lambda (a) (cdr (car (car a)))) )
(define cdadr (lambda (a) (cdr (car (cdr a)))) )
(define cddar (lambda (a) (cdr (cdr (car a)))) )
(define cdddr (lambda (a) (cdr (cdr (cdr a)))) )

(define caaaar (lambda (a) (car (car (car (car a))))) )
(define caaadr (lambda (a) (car (car (car (cdr a))))) )
(define caadar (lambda (a) (car (car (cdr (car a))))) )
(define caaddr (lambda (a) (car (car (cdr (cdr a))))) )

(define cadaar (lambda (a) (car (cdr (car (car a))))) )
(define cadadr (lambda (a) (car (cdr (car (cdr a))))) )
(define caddar (lambda (a) (car (cdr (cdr (car a))))) )
(define cadddr (lambda (a) (car (cdr (cdr (cdr a))))) )


(define cdaaar (lambda (a) (cdr (car (car (car a))))) )
(define cdaadr (lambda (a) (cdr (car (car (cdr a))))) )
(define cdadar (lambda (a) (cdr (car (cdr (car a))))) )
(define cdaddr (lambda (a) (cdr (car (cdr (cdr a))))) )

(define cddaar (lambda (a) (cdr (cdr (car (car a))))) )
(define cddadr (lambda (a) (cdr (cdr (car (cdr a))))) )
(define cdddar (lambda (a) (cdr (cdr (cdr (car a))))) )
(define cddddr (lambda (a) (cdr (cdr (cdr (cdr a))))) )

; more primitives
;
(define newline (lambda () (display "\n")))
(define else #t)  ;; should be a keyword in cond
(define list (lambda args args))

; not does not work as macro in rxrs test!
;
(define not (lambda (a) (if a #f #t)))

; identity procedure
;
(define I (lambda (x) x))

(define match-taglist (lambda (lst tag)
  (if (not (pair? lst) ) 
      #f
      (eq? (car lst) tag)  )))

(define make-lambda (lambda (form body)
  (cons 'lambda (cons form body))  ))

; display args separated by a leading space 
;
(define displayn (lambda args
  (if (null? args) 
      (display "\n") 
      (progn 
        (display " ")
        (display (car args)) 
        (apply displayn (cdr args))  ))))

(load "pc-adt-kv.sim")
(load "pc-adt-alist.sim")

(define list-ref (lambda (a n)
  (cond ((null? a) ())
        ((eq? n 0) (car a))
        (else (list-ref (cdr a) (- n 1)))  )  ))

; load macros

(load "pc-scheme.mac")


(load "pc-adt-env.sim")
(load "pc-streams.sim")

; print args separated by a leading space 
;
(define printn (lambda (a . r)
  (cond ((null? a) (error "printn: nothing to do"))
        ((string? a) (display a) (display " "))
        (else (print a) (display " "))  )
  (cond ((null? r) (newline)) 
        (else (apply printn r))  )  ))

(define peek (lambda (mess . args)
  ;(indent indent-level) 
  (display mess)
  (displayn args)  ))

(define error (lambda (mes . tem)
  (printn "Error in" (apply make-expn tem) mes)  ))

; min and max
;
(define max2 (lambda (a b) (if (> a b) a b)))
(define min2 (lambda (a b) (if (< a b) a b)))

(define max (lambda (a . r)
  (cond ((null? a) (error ": need 1 or more arguments" '(max)))
        ((not (number? a)) (error ": number expected" '(max ?0 . ?1) a r))
        ((null? r) a)
        (else (max2 a (apply max r)))  )  ))

(define min (lambda (a . r)
  (cond ((null? a) (error ": need 1 or more arguments" '(min)))
        ((not (number? a)) (error ": number expected" '(min ?0 . ?1) a r))
        ((null? r) a)
        (else (min2 a (apply min r)))  )  ))

; FIXME: this need to go after all RxRS is defined

; closure ADT
;   (closure <proc> env G)
;
(define (closure? c) (match-taglist c 'closure))
(define (closure-proc c) (cadr c))
(define (closure-env c) (cdddr c))

; use implementation knowledge to get null-environment
;
(define null-environment (closure-env (lambda () 'nothing)))
print null-environment
;(exit 1)

;; simplispic version of equal?
(define _equal? (lambda (a b)
  (if (eq? a b) 
      #t
      (if (and (pair? a) (pair? b) ) 
          (if (_equal? (car a) (car b)) 
              (_equal? (cdr a) (cdr b)) 
              #f  )
          #f  )  )  ))


; force a promise - force is not a special form

(define force (lambda (p) (p))) 

(define list-tail (lambda (x k)
  (if (zero? k)
      x
      (list-tail (cdr x) (- k 1))  )))


(define make-promise (lambda (proc)
  (let ((result-ready? #f)
        (result #f))
       (lambda ()
               (if result-ready?
                   result
                   (let ((x (proc)))
                        (if result-ready?
                            result
                            (begin (set! result-ready? #t)
                                   (set! result x)
                                   result  ))))))  ))
(define make-promise-pc (lambda (proc)
  (let ((result-ready? #f)
        (result #f))
       (lambda ()
               (if result-ready?
                   result
                   (let ((x (proc)))
                        (set! result-ready? #t)
                        (set! result x)
                        result  ))))  ))
;make-promise

(define x (make-promise-pc (lambda () (+ 2 3))))
x
(force x)
;(exit 1)

;; an expected test

(define (fact n)
  (if (= n 0)
      1
      (* n (fact (- n 1)))  )  )

(? 1 '(fact 0))
(? 1 '(fact 1))
(? 120 '(fact 5))

;;;;;;;;;; tests
           
;; a version of car, cdr and cons using lambda

(define kar (lambda (z) (z (lambda (p q) p))))
(define kdr (lambda (z) (z (lambda (p q) q))))
(define kons (lambda (x y) (lambda (m) (m x y))))

;; another version that is easier to understand but needs if

(define kons2 (lambda (a b) (lambda (m) (if (eq? m 1) a b))))
(define kar2 (lambda (x) (x 1)))
(define kdr2 (lambda (x) (x 2)))

; is atm a member of an improper list?

(define (member-imp? atm lst)
  (cond ((null? lst) #f)
        ((eq? atm (car lst)) #t)
        ((eq? atm (cdr lst)) #t)
        (else (member-imp? atm (cdr lst)))  ))
        
(define pr (lambda (a)
  (if (atom? a)
      (print a)
      (progn (print \() (pr (car a)) (pr (cdr a)) (print \)))  )
))

;(define eval-cond (lambda (conds bindings)
;  (if ((eval (car (car conds)) bindings)
;      (eval (car (cdr (car conds))) bindings))
;      (eval-cond (cdr conds) bindings)  )  ))

; various list implementations
;
(? '(1 2 3) '(list 1 2 (+ 1 2)))
(define pc-list3 (lambda (first . rest) (cons first rest) ) )

(define (_append a b)
  (cond ((null? a) b)
        ((null? b) a)
        (else (cons (car a) (_append (cdr a) b))  )  ))

(define (append . args)
  (cond ((null? args) '())
        ((null? (cdr args)) (car args) )
        (else (_append (car args) (apply append (cdr args))) )  ))


(? '(1 2) '(_append '(1 2)))
;(exit 2)
(? '(1 2) '(_append '(1 2) '()))
(? '(1 2) '(_append '() '(1 2)))
(? '(1 2 3 4) '(_append '(1 2) '(3 4)))
(? '(1 2 . 3) '(_append '(1 2) 3))
(? '(1 2 3 . 4) '(_append '(1 2) '(3 . 4)))

            
(let () (print 1) )
;no good(let* () (print 1) )
(let* ((a 1)) (print a) )
(let* ((a 1) (b (+ a 1))) (print b) )
(let* ((a 1) (b (+ a 2))) (print a) (print b) )

(define (reverse a)
  (if (null? a)
     '()
     (append (reverse (cdr a)) (list (car a)) )  ))
     
(define (gcd a b)
  (if (= b 0) a
      (gcd b (modulo a b))))
      
(? 1 '(gcd 1 2))      
(? 1 '(gcd 1 9))      
(? 9 '(gcd (* 7 9) (* 5 9)))      

(define (gcd-euclid a b)
  (if (= b 0)
      a
      (if (> b a) 
          (gcd-euclid (- b a) a) 
          (gcd-euclid (- a b) b)  )))
(? 1 '(gcd-euclid 1 2))      
(? 1 '(gcd-euclid 1 9))      
(? 9 '(gcd-euclid (* 7 9) (* 5 9)))      

(define (for-each proc list)
  (cond ((null? list) "done")
        (else (proc (car list))
              (for-each proc (cdr list) )  )))
;(? '(1 4 9) '(for-each (lambda (x) (printerr (* x x))) '(1 2 3)))

; another member?
(define (member? x list)
     (cond ((null? list) #f)
           ((not (list? list)) #f)
           ((equal? x (car list)) #t)
           (else   (member? x (cdr list)))  ))
           
(define (member x lst)
  (cond ((null? lst) #f)
        ((equal? (car lst) x) lst)
        (else (member x (cdr lst)))  ))

(define (for-each f lst)
	(if (not (null? lst))
    (begin
	    (f (car lst))
	    (for-each f (cdr lst))  )
	  '()  ))

(define (map-list f l)
  (if (null? l)
    '()
     (cons (f (car l)) (map-list f (cdr l)) ) ))

; FIXME: not really map

(define map map-list)

;; convert procedures into cps form
;(define (cps-prim f)
; (lambda args
;  (let ((r (reverse args)))
;   ;(print "r=")
;   ;(print r)
;   ((car r) (apply f
;             (reverse (cdr r))))))  )

;(define *& (cps-prim *))
;(define +& (cps-prim +))
;(+& 2 3 (lambda (x) (print x)))

; FIXME: no map-car

;(define (map f . a*)
;  (let
;    ((carof
;       (lambda (a)
;         (map-car car a)))
;     (cdrof
;       (lambda (a)
;         (map-car cdr a)))
;     (_map
;       (lambda (a* r)
;         (cond ((null? (car a*)) (reverse r))
;           (else (_map (cdrof a*)
;                 (cons (apply f (carof a*)) r)))))))
;    (cond ((null? a*)
;        (bottom '(too few arguments to map)))
;      (else (_map a* '())))))

(load "pc-r4rstest.sim")

;;;;;;;;;; keep last
;
(if (> ?count 0)
  (displayn "Error: Toy library failed verification tests\n" "errors=" ?count)
  (displayn "Note: Toy library passed verification tests\n")  )

