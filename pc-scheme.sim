"Loading a Toy Scheme Library..."

(define pc-scheme.sim #t)

(define eqv? eq?)
(define null?      (lambda (a) (eq? a '())))

; more primitives
;
(define newline (lambda () (display "\n")))
(define else #t)  ; FIXME: should be a keyword in cond

; Return a list of evaluated arguements
;   Since applicative order evaluates arguments and makes a list, just return arguments
;
(define list (lambda a a))

;(define + (lambda a
;  (if (null? a) 0 (int+ (car a) (apply + (cdr a))  ))  ))

(define + (lambda (s . a)
  (cond ((null? s) 0)
        ((null? a) s)
        (else (int+ s (apply + a)))  )  ))

;(define * (lambda a
;  (if (null? a) 1 (int* (car a) (apply * (cdr a))  ))  ))

(define * (lambda (s . a)
  (cond ((null? s) 1)
        ((null? a) s)
        (else (int* s (apply * a)))  )  ))

(define - (lambda (s . a)
  (cond ((null? s) 0)
        ((null? a) (int- 0 s))
        (else (int- s (apply + a)))  )  ))

;(-)
;(- 1)
;(- -1)
;(- 10 3)
;(- -2 5)
;(exit 1)

; division, quotient, remainder, modulo etc.

(define / (lambda (s . a)
  (cond ((null? s) 1)
        ((null? a) (int/ 1 s))
        (else      (int/ s (apply * a)))  )  ))

(define quotient /)

(define remainder int%)

(define modulo (lambda (a b)
  ((lambda (rem) 
           (cond ((eq? rem 0) 0)
                 ((eq? (int< a 0) (int< b 0)) rem)
                 (else (int+ b rem))  )  )
   (remainder a b)  )  ))
   
; generalised multi-value predicate
;
(define _int-op (lambda (op? f . r)
  (cond ((null? f)        #f)                                  ; instead of error
        ((null? r)        #t)                                  ; only 1 arg
        ((op? f (car r))                                       ; test adj. pairs
                          (apply _int-op (cons op? r)))
        (else             #f))  ))                             ; failed

; make a procedure to process multi-value number predicates
; works and no memory leaks but creates a new procedure for each predicate
;
(define make-int-op (lambda (op?)
  (define op (lambda (f . r)
    (cond ((null? f) #f)
          ((null? r) #t)
          ((op? f (car r)) (apply op r))
          (else        #f) 
    ) 
  ))
  op
))

;(define =  (make-int-op int=))
(define =  (lambda a (apply _int-op (cons int=  a))))
(define <  (lambda a (apply _int-op (cons int<  a))))
(define <= (lambda a (apply _int-op (cons int<= a))))
(define >  (lambda a (apply _int-op (cons int>  a))))
(define >= (lambda a (apply _int-op (cons int>= a))))

;(define x <)

;(x)
;(x 10)
;(x 10 10)
;(x 10 10 10)
;(x 10 10 10 10)
;(x 10 11)
;(x 10 10 11)
;(x 10 11 12 13)
;(x 13 12 11 10)
;(x 10 11 11 12)
;(x 12 11 11 10)

;(exit 1)

; FIXME: a procedure is also a pair
; FIXME: do set!

; symbol functions can use string functions in many cases
;
(define symbol-ref string-ref)
(define symbol-length string-length)

(define CHAR     (tag #\a)       )
(define PAIR     (tag '(a apair)))
(define NUMBER   (tag 1)         )
(define SYMBOL   (tag 'aSymbol)  )
(define STRING   (tag "a string"))
(define CONSTANT (tag #t)        )

(define char?      (lambda (a) (eq? (tag a) CHAR)))
(define pair?      (lambda (a) (eq? (tag a) PAIR)))
(define number?    (lambda (a) (eq? (tag a) NUMBER)))
(define symbol?    (lambda (a) (eq? (tag a) SYMBOL)))
(define string?    (lambda (a) (eq? (tag a) STRING)))
(define constant?  (lambda (a) (eq? (tag a) CONSTANT)))

; FIXME: what is a procedure?

(define atom? (lambda (a)
  (if (null?     a) #t
  (if (symbol?   a) #t
  (if (constant? a) #t
  (if (number?   a) #t
  (if (string?   a) #t
      (char?     a)  )))))  ))
                  
(define boolean? (lambda (b) (if (eq? b #t) #t (eq? b #f)) ))

(define false? (lambda (b) (eq? b #f)))
(define true?  (lambda (b) (not (false b))))

; simplispic version of equal?
;
(define equal? (lambda (a b)
  (if (eqv? a b) #t 
      (if (pair? a)
          (if (pair? b)
              (if (equal? (car a) (car b)) 
                  (equal? (cdr a) (cdr b))
                  #f  )
              #f  )
       #f  ))  )) 

; simple test
; like r4rstest.scm this fails if some functions are macros
; eg. if abs is a macro, abs will not be transformed and hence fail
; To 'fix' this, have a backup function
;

(define _test-process (lambda (expect result)
  (cond ((equal? result expect) (display "  pass\n") #t)
        (else                   (display "  FAIL! Got ") 
                                (print result) (display "\n") (exit 1) #f  ))  ))

(define test (lambda (expect f . a)
  (display "test exp= ") (print (cons f a)) (display " -> ") (print expect)
  (_test-process expect (apply f a))  ))
  
; My test harness - based on r4rstest.scm
; Except I quote expression to test so I can allow macro expansion
;
; (pc-test expect expression)
; eg (pc-test 3 '(+ 1 2))
;
(define pc-test-count 0)  ; count errors
(define pc-test-stop 1)   ; stop after this many errors

; FIXME: let causes _cm_check_mem_leak to fail
; define version doe not

(define _pc-test-process (lambda (expect result)
  (cond ((equal? result expect) (display "...pass.  ") #t )
        (else (set! pc-test-count (int+ pc-test-count 1))
              (display "...FAIL! Got  ") (print result) (display ".  ")
              (if (eq? pc-test-count pc-test-stop) (exit) #f)  ))  ))

(define pc-test (lambda (expect exp)
  (display "test  ") (print exp) (display " -> ") (print expect)
  (if eval-macro
    (_pc-test-process expect (eval1 (eval-macro exp)))
    (_pc-test-process expect (eval1 exp))  )  ))

(define ? pc-test)  ; quick hack to avoid fixing this up

(define caar (lambda (a) (car (car a))) )
(define cadr (lambda (a) (car (cdr a))) )
(define cdar (lambda (a) (cdr (car a))) )
(define cddr (lambda (a) (cdr (cdr a))) )

(define caaar (lambda (a) (car (car (car a)))) )
(define caadr (lambda (a) (car (car (cdr a)))) )
(define cadar (lambda (a) (car (cdr (car a)))) )
(define caddr (lambda (a) (car (cdr (cdr a)))) )

(define cdaar (lambda (a) (cdr (car (car a)))) )
(define cdadr (lambda (a) (cdr (car (cdr a)))) )
(define cddar (lambda (a) (cdr (cdr (car a)))) )
(define cdddr (lambda (a) (cdr (cdr (cdr a)))) )

(define caaaar (lambda (a) (car (car (car (car a))))) )
(define caaadr (lambda (a) (car (car (car (cdr a))))) )
(define caadar (lambda (a) (car (car (cdr (car a))))) )
(define caaddr (lambda (a) (car (car (cdr (cdr a))))) )

(define cadaar (lambda (a) (car (cdr (car (car a))))) )
(define cadadr (lambda (a) (car (cdr (car (cdr a))))) )
(define caddar (lambda (a) (car (cdr (cdr (car a))))) )
(define cadddr (lambda (a) (car (cdr (cdr (cdr a))))) )


(define cdaaar (lambda (a) (cdr (car (car (car a))))) )
(define cdaadr (lambda (a) (cdr (car (car (cdr a))))) )
(define cdadar (lambda (a) (cdr (car (cdr (car a))))) )
(define cdaddr (lambda (a) (cdr (car (cdr (cdr a))))) )

(define cddaar (lambda (a) (cdr (cdr (car (car a))))) )
(define cddadr (lambda (a) (cdr (cdr (car (cdr a))))) )
(define cdddar (lambda (a) (cdr (cdr (cdr (car a))))) )
(define cddddr (lambda (a) (cdr (cdr (cdr (cdr a))))) )


; backup function for macro
;
(define not       (lambda (a) (if a #f #t)))
(define abs       (lambda (a) (if (number? a) (if (int>= a 0) a (int- 0 a)) #f)))
(define zero?     (lambda (a) (eq? a 0)))
(define even?     (lambda (a) (if (number? a) (eq? (remainder a 2) 0) #f) ))
(define odd?      (lambda (a) (if (number? a) (not (eq? (remainder a 2) 0)) #f) ))
(define positive? (lambda (a) (if (number? a) (int> a 0) #f) ))
(define negative? (lambda (a) (if (number? a) (int< a 0) #f) ))

; identity procedure
;
(define I (lambda (x) x))

(define match-taglist (lambda (lst tag)
  (if (not (pair? lst) ) 
      #f
      (eq? (car lst) tag)  )))

(define procedure? (lambda (p) (match-taglist p 'closure)))

(define make-lambda (lambda (form body)
  (cons 'lambda (cons form body))  ))

; force a promise - force is not a special form
;
(define force (lambda (p) (p))) 

; display args separated by a leading space 
;
(define displayn (lambda (a . r)
  (cond ((null? a)   (error "displayn: nothing to do"))
        (else        (display a) (display " "))  )
  (if (null? r) (newline) (apply displayn r))  ))

; print args separated by a leading space 
;
(define printn (lambda (a . r)
  (cond ((null? a)   (display "printn: nothing to do"))
        ((string? a) (display a) (display " "))
        (else        (print a) (display " "))  )
  (if (null? r) (newline) (apply printn r))  ))

;(define indent (lambda (n)
;  (if (= n 0) '() (progn (print "  ") (indent (- n 1))))  ))

;(define indent-level 0)

(define peek (lambda (mess . args)
  ;(indent indent-level) 
  (display mess)
  (displayn args)  ))


(load "pc-lists.sim")
(load "pc-math.sim")

;;;;;;;;;;

; need a basic error until macros loaded
;
(define error (lambda (mes . tem)
  (printn "Error in" tem mes)  ))


(load "pc-adt-kv.sim")
(load "pc-adt-alist.sim")

; load macros
;
(load "pc-scheme.mac")

; A more fancy error function can now be made
;
(define error (lambda (mes . tem)
  (printn "Error in" (apply make-expn tem) mes)  ))

; load other ADTs here
;
(load "pc-adt-env.sim")
(load "pc-streams.sim")



; FIXME: this need to go after all RxRS is defined

; closure ADT
;   (closure <proc> env G)
;
(define (closure? c) (match-taglist c 'closure))
(define (closure-proc c) (cadr c))
(define (closure-env c) (cdddr c))

; use implementation knowledge to get null-environment
;
(define null-environment (closure-env (lambda () 'nothing)))
print null-environment

(define make-promise (lambda (proc)
  (let ((result-ready? #f)
        (result #f))
       (lambda ()
               (if result-ready?
                   result
                   (let ((x (proc)))
                        (if result-ready?
                            result
                            (begin (set! result-ready? #t)
                                   (set! result x)
                                   result  ))))))  ))

(define make-promise-pc (lambda (proc)
  (let ((result-ready? #f)
        (result #f))
       (lambda ()
               (if result-ready?
                   result
                   (let ((x (proc)))
                        (set! result-ready? #t)
                        (set! result x)
                        result  ))))  ))
;make-promise

;(define x (make-promise-pc (lambda () (+ 2 3))))
;x
;(force x)
;(exit 1)


;;;;;;;;;; tests
           
; a version of car, cdr and cons using lambda
;
;(define kar (lambda (z) (z (lambda (p q) p))))
;(define kdr (lambda (z) (z (lambda (p q) q))))
;(define kons (lambda (x y) (lambda (m) (m x y))))

; another version that is easier to understand but needs if
;
;(define kons2 (lambda (a b) (lambda (m) (if (eq? m 1) a b))))
;(define kar2 (lambda (x) (x 1)))
;(define kdr2 (lambda (x) (x 2)))

        
(define pr (lambda (a)
  (if (atom? a)
      (print a)
      (progn (print \() (pr (car a)) (pr (cdr a)) (print \)))  )
))

;(define eval-cond (lambda (conds bindings)
;  (if ((eval (car (car conds)) bindings)
;      (eval (car (cdr (car conds))) bindings))
;      (eval-cond (cdr conds) bindings)  )  ))

;; convert procedures into cps form
;(define (cps-prim f)
; (lambda args
;  (let ((r (reverse args)))
;   ;(print "r=")
;   ;(print r)
;   ((car r) (apply f
;             (reverse (cdr r))))))  )

;(define *& (cps-prim *))
;(define +& (cps-prim +))
;(+& 2 3 (lambda (x) (print x)))

; FIXME: no map-car

;(define (map f . a*)
;  (let
;    ((carof
;       (lambda (a)
;         (map-car car a)))
;     (cdrof
;       (lambda (a)
;         (map-car cdr a)))
;     (_map
;       (lambda (a* r)
;         (cond ((null? (car a*)) (reverse r))
;           (else (_map (cdrof a*)
;                 (cons (apply f (carof a*)) r)))))))
;    (cond ((null? a*)
;        (bottom '(too few arguments to map)))
;      (else (_map a* '())))))

(load "pc-r4rstest.sim")

;;;;;;;;;; keep last
;
(if (int> pc-test-count 0)
  (displayn "Error: Toy library failed verification tests\n" "errors=" pc-test-count)
  (displayn "Note: Toy library passed verification tests\n")  )

