"Loading a Toy Scheme Macros..."
(define pc-scheme.mac #t)

;(define warn (lambda (mess name atom) (cons mess (cons name atom)) ))

; key-value pairs (key . value)

(define make-kvp (lambda (key val) (cons key val)))
(define kvp-key (lambda (kvp) (car kvp)))
(define kvp-val (lambda (kvp) (cdr kvp)))

; key-value lists (key value) - uses 1 extra pair

(define make-kvl (lambda (key val) (list key val)))
(define kvl-key (lambda (kvl) (car kvl)))
(define kvl-val (lambda (kvl) (cadr kvl)))

; associative list ((k . v) (k . v) ...)

(define make-alist (lambda (keys vals)
  (cond ((null? keys) (if (null? vals) '() (make-alist "Not enough keys for values" vals)))
        ((atom? keys) (list (make-kvp keys vals)) )  ; key=(v v ...)
        ((null? vals) (list (make-kvp (car keys) '())
                            (make-alist (cdr keys) '())) )  ; missing values are ()
        (else (list (make-kvp (car keys) (car vals))
                    (make-alist (cdr keys) (cdr vals)))  )) 
))

(define extend-alist (lambda (kvp alst) (cons kvp alst)))

(define alist-assoc (lambda (key alst)
  ;(displayn "alist-assoc  key=[" key "]  alst=[" alst "]")
  (cond ((null? alst) #f)
        ((eq? key (kvp-key (car alst))) 
         ;(peek "found key->" (car alst))
         (car alst))
        (else (alist-assoc key (cdr alst)))  )))

(define alist-lookup (lambda (key alst)
  ;(displayn "alist-lookup  key=[" key "]  alst=[" alst "]")
  (cond ((null? alst) key)
        ((eq? key (kvp-key (car alst))) (kvp-val (car alst)))
        (else (alist-lookup key (cdr alst)))  )))
  
(define assocv2 (lambda (sym env)
  (cond ((null? env) #f)
        (else
          ((lambda (kvp)
                   (if kvp 
                       kvp 
                       (assoc sym (cdr env))  ))
           (alist-assoc sym (car env)))  ))))

(define assoc (lambda (sym env)
  (cond ((null? env) #f)
        (else
          (define kvp (alist-assoc-fail sym (car env) #f)) 
          (if kvp 
              kvp 
              (assoc sym (cdr env))  )))))

; (and) -> #t
; (and a) -> a
; (and a1 a2) -> (if a1 a2 #f)
; (and a1 a2 a3) -> (if a1 (if a2 a3 #f) #f)
;($s $n)

(define indent (lambda (n)
  (if (= n 0) '() (progn (print "  ") (indent (- n 1))))  ))

(define indent-level 0)

; display args separated by a leading space 

(define displayn (lambda args
  (if (null? args) 
      (display "\n") 
      (progn 
        (display " ")
        (display (car args)) 
        (apply displayn (cdr args))  ))))

(displayn 1)
(displayn 1 "2")
(displayn 1 "" "2" "23" "234" "2345" 't 'th 'thr 'three)
(displayn 1 2 'three 4)
;(exit 1)

(define peek (lambda (mess . args)
  ;(indent indent-level) 
  (display mess)
  (displayn args)  ))

; define or match a symbol

(define match-or-define-variable (lambda (kvp var exp env)
  ;(displayn "modv: kvp=[" kvp "]  var=[" var  "]  exp=[" exp  "]  env=[" env "]")
  (cond (kvp  ;(displayn "  variable found var=" var "]  val=[" (kvp-val kvp) "]")
              (if (equal? (kvp-val kvp) exp) env #f)
              ;(if (match? (kvp-val kvp) exp env) env #f)     ; FIXME: match?
        )     
        (else (extend-alist (make-kvp var exp) env))  )))

; does template match expression given environment

(define var? (lambda (tem)
  (if (symbol? tem)
      (if (eq? (symbol-ref tem 0) #\?) 
          (if (> (symbol-length tem) 1) #t #f) 
          #f  )
      #f  )
))

(equal? '() '())
(equal? '(1) '())
(equal? 1 1)
(equal? 'a 'a)
(equal? 'abcd 'abcd)
(equal? "a" "a")
(equal? "abcd" "abcd")
(equal? '(1 a) '(1 a))
(equal? '(1 (2 () 3) a) '(1 (2 () 3) a))

(define match (lambda (pat exp env)
  ;(displayn "match pat=[" pat "]  exp=[" exp "]  env=[" env "]")
  (cond 
        ((eq? env #f) #f)
        ; SICP place
        ;((eq? pat exp) env)
        ((equal? pat exp) env)
        ((var? pat)   ;(displayn "var=" pat)
                      (match-or-define-variable (alist-assoc pat env) pat exp env)  )
        ((pair? pat)  ;(displayn "pair=" pat)
                      (if (pair? exp) 
                          (match (cdr pat) 
                                 (cdr exp) 
                                 (match (car pat) (car exp) env)  )
                          #f  ))
        (else         ;(displayn "unknown list element") 
                      #f)  )
))


(match '() '() '())
(match '(1) '() '())
(match '() '(1) '())
(match '(1) '(1) '())
(match '(1) '(2) '())
(match '(1 2 "3" (4 #\5 () 7) (8)) '(1 2 "3" (4 #\5 () 7) (8)) '())
(match '(?x) '(2) '())
(match '(1 ?x) '(1 ("this is x")) '())
(match '(1 ?x (?x 2)) '(1 ("x") (("x") 2)) '())
(match '(1 ?x (?x 2)) '(1 ("x") (("y") 2)) '())

(match '(define (?name . ?args) ?body) 
       '(define (inc x) (+ x 1)) 
       '()  )

(match '?nil '() '())

; for a var, no need to perform macro expansion since we assume it is already
; done during read.
; but after a pair we should check
; macros in transformers should NOT go through macro expansion

(define make-exp (lambda (tem env)
  ;(displayn "make-exp  tem=[" tem "]  env=[" env "]")
  (cond 
        ( (null? tem)  '() )
        ( (var? tem)   (alist-lookup tem env) )
        ( (atom? tem)  tem  )
        ( (pair? tem)  (eval-macro (cons (make-exp (car tem) env) 
                                         (make-exp (cdr tem) env)  )  ))
        (else          (display "unknown\n") #f )  )
))

(define transformers '(
  ((define (?n . ?a) . ?b) (define ?n (lambda . ?a) . ?b)) 
  ((begin . ?b) (progn . ?b)) 
  ((inc ?a) (+ ?a 1)) 
  ((dec ?a) (1 ?a 1)) 
  ((not ?e) (if ?e #f #t))
  ((and) #t)  
  ((and ?e) ?e) 
  ((and ?e1 . ?e2) (if ?e1 (and . ?e2) #f)) 
  ((or) #f)  
  ((or ?e) ?e) 
  ((or ?e1 . ?e2) (if ?e1 #t (or . ?e2))) 
  ((let  () . ?b) ((lambda () . ?b)))
  ;((let  () . ?b) (progn . ?b))
  ((let  ((?f ?e)) . ?b) ((lambda (?f) . ?b) ?e))
  ((let* ((?f ?e)) . ?b) ((lambda (?f) . ?b) ?e))
  ((let* ((?f ?e) . ?r) . ?b) ((lambda (?f) (let* ?r . ?b)) ?e))
  ((letrec () . ?b) (let () ?b))
  ; why inner let? ((letrec ((?f ?e)) . ?b) (let () (define ?f ?e) (let () . ?b)))
  ;((letrec ((?f ?e)) . ?b) (let () (define ?f ?e) . ?b))

  ((letrec->define () . ?b) ?b )
  ((letrec->define (?d . ?r) . ?b) ((define . ?d) . (letrec->define ?r . ?b)) )

  ((letrec ?v . ?b) (let () . (letrec->define ?v . ?b)))
  
  ((cons-stream ?a ?b) (cons ?a (delay ?b)))

))
; (let () (+ 1 2)) -> ((lambda () (+ 1 2)))

; macro is (pattern template)
(define macro-pat (lambda (macro) (car macro) ))
(define macro-tem (lambda (macro) (cadr macro) ))

; patern is (key . rest)
(define pat-key (lambda (pat) (car pat) ))
(define pat-rest (lambda (pat) (cdr pat) ))

(define exp-tag (lambda (exp) (car exp)))

(define eval-macro-worker (lambda (exp trans)
  (cond ((null? trans) exp)      ; no more translations
        ((atom? exp) exp)        ; we don't translate atoms
        ((not (eq? (pat-key (macro-pat (car trans))) (exp-tag exp)))
         (eval-macro-worker exp (cdr trans))  )
        (else
         ((lambda (env)
                  (cond (env (make-exp (macro-tem (car trans)) env) ) 
                        (else (eval-macro-worker exp (cdr trans)))  )) 
          (match (macro-pat (car trans)) exp '())  )))))
         
(define eval-macro (lambda (exp) (eval-macro-worker exp transformers) ))

; test

(define ?count 0)  ;; count errors

(define ? (lambda (expect exp)
  (displayn "test exp=" exp "->" expect)
  ;(define result (eval1 exp))  ;; FIXME: this is bad
  (let ((result (eval1 exp)))
    (cond ((equal? result expect) (display "  pass\n") #t )
          (else (set! ?count (+ ?count 1))
                (displayn "FAIL! Got" result)
                (if (= ?count 5) (exit) #f )  )  )
  )   
))

(let () (+ 1 4))
;(letrec->define ((x 1)(y 2)(z 3)))
(letrec ((x 1)) (+ x 1))
(letrec ((x 1) (y 2) (z 3)) (+ x y z))
;(? 5 '(+ 2 3 1))
(exit 1)

; org (don't process atoms) (remove nil () ()) (match tag of list) (no macro) (macro)
;     (alist-assoc-fail) (eliminate assoc defines) | (SICP-like version)
;     (SICP version with eq instead of equal)
;     (SICP version with equal) (no make-exp on var?)
;     (eval-macro of cons and on var)
;     (eval-macro of cons and on var)
; # (no eval-macro on var)

1  ; 2580 23 232 23 8 23 23 | 23 23 23 23
; # 23
+  ; 2580 23 23 23 8 23 23 | 23 23 23 23
; # 23
(+)  ; 9978 (+7398) 4928 4808 823 32 823 823 | 823 823 943 943
; # 943
(+ 1)  ; 12582 (+2604) 4975 4855 870 64 870 870 | 870 870 990 990
; # 990
(+ 1 2)  ; 15186 (+2604) 5022 4902 917 96 917 917 | 917 917 1037 1037
; # 1037
(+ 1 2 3)  ; 17790 (+2604) 5069 4949 964 128 964 964 | 964 964 1084 1084
; # 1084
(+ 1 2 3 4)  ; 20394 (+2604) 5116 4996 1011 160 1011 1011 | 1011 1011 1131 1131
; # 1131
(inc 3)  ; ... 3360 3378 | 3299 3253 3234 1832 3568
; # 3549
(begin 1 (inc 2) (+ 2 3))  ; ... 7270 7306 | 7132 7046 6262 4354 6960
; # 6056
(and)  ; ... 586 589 | 565 525 445 496 481
; # 481
(and 2)  ; ... 1129 1144 | 1052 978 959 1023 1027
; # 1008
(and (= 1 2) (= 3 4) (= 5 6))  ; ... 21921 22050 | 21282 20992 17167 12187 19165
; # 14740
;(or)
;(or 2)
;(or (= 1 2) (= 3 4) (= 5 6))
;(let ((x 3)) (+ x 3))
(let* ((x 3)) (+ x 3))  ; ... 10436 10496 | 10261 10197 9394 7888 10528
; # 9605
(let* ((x 3) (y 4)) (+ x y))  ; ... 23892 20478 | died 22985 20614 15946 22977
; # 20246
(exit 1)

; keep last

(display "Macros loaded.") (newline)

(exit 1)

