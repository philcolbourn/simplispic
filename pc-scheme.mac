"Loading a Toy Scheme Macros..."

(define pc-scheme.mac #t)

;(define warn (lambda (mess name atom) (cons mess (cons name atom)) ))
;
;can we keep record of defines so we know what file some function came from?
;maybe modify define to record filename in env
;
;(define requires (lambda (dep)
;  (if dep (displayn dep "loaded.") (load dep))))

;(requires "pc-adt-kv.sim")

; define or match a symbol

(define match-or-define-variable (lambda (kvp var exp env)
  ;(displayn "modv: kvp=[" kvp "]  var=[" var  "]  exp=[" exp  "]  env=[" env "]")
  (cond (kvp  ;(displayn "  variable found var=" var "]  val=[" (kvp-val kvp) "]")
              (if (equal? (kvp-val kvp) exp) env #f)
              ;(if (match? (kvp-val kvp) exp env) env #f)     ; FIXME: match?
        )     
        (else (extend-alist (make-kvp var exp) env))  )))

; Return true if a pattern variable
; A variable is ?x where x is something
;
(define pat-var? (lambda (v)
  (if (symbol? v)
      (if (eq? (symbol-ref v 0) #\?) 
          (if (int> (symbol-length v) 1) #t #f) 
          #f  )
      #f  )  ))

(define pat-cond-tag (lambda (c) (car c)))

      
; Return condition of a pattern conditional variable
;
(define pat-cond-pred (lambda (c) (cadr c)))

(define pat-cond-var (lambda (c) (caddr c)))

; Rturn true if a pattern conditional
; eg. ("req" atom? ?a) means pattern expects an atom
;
(define pat-cond? (lambda (c)
  ;(displayn "pat-cond?  c=" c)
  (if (pair? c)
  (if (string? (pat-cond-tag c))
  (if (pair? (cdr c))
  (if (symbol? (pat-cond-pred c))
  (if (pair? (cddr c))
  (if (pat-var? (pat-cond-var c))  #t #f)  #f) #f ) #f) #f) #f)  ))


(define char->num '(
  (#\0 . 0)
  (#\1 . 1)
  (#\2 . 2)
  (#\3 . 3)
  (#\4 . 4)
  (#\5 . 5)
  (#\6 . 6)
  (#\7 . 7)
  (#\8 . 8)
  (#\9 . 9)
))

; hack to convert a pattern variable to a number
;
(define var->ref (lambda (var)
  (if (symbol? var)
      (if (eq? (symbol-ref var 0) #\?) 
          (alist-lookup (symbol-ref var 1) char->num)
          #f  )
      #f  )  ))

; Apply a named predicte to a value
; Pedicate is a symbol. eg. 'atom? and value is used as a list
;
(define test-cond? (lambda (p? a)
  ;(displayn "test-cond?  p?=" p? "  a=" a)
  (apply (eval1 p?) (list a))  ))

;(define pc-apply (lambda (p . a)
;  (p a)  ))

;(apply cons '("car" "cdr"))
;(define x 3)
;(apply cons '(x 12))
;(apply (eval1 'cons) '(x 12))
;(define exp 3)

;(test-cond? 'atom? exp)
;exp
;(exit 1)

; does template match expression given environment
;
(define match (lambda (pat exp env)
  ;(displayn "match pat=[" pat "]  exp=[" exp "]  env=[" env "]")
  (cond 
        ((eq? env #f)     #f)
        ; SICP place
        ;((eq? pat exp)    env)
        ((equal? pat exp) env)
        ((pat-var? pat)   ;(displayn "var=" pat)
                          (match-or-define-variable (alist-assoc pat env) 
                                                pat 
                                                exp 
                                                env)  )
;        ((pat-cond? pat)  (displayn "pat=" pat "  pat-cond-pred=" (pat-cond-pred pat) 
;                                    "  pat-cond-var=" (pat-cond-var pat) "  exp=" exp)  )
        ((pat-cond? pat)  ;(displayn "pat=" pat "  pat-cond-pred=" (pat-cond-pred pat) 
                          ;          "  pat-cond-var=" (pat-cond-var pat) "  exp=" exp)
                          (if (test-cond? (pat-cond-pred pat) exp)  ; exp matches conditional
                              (match-or-define-variable (alist-assoc (pat-cond-var pat) env) 
                                                        (pat-cond-var pat) 
                                                        exp 
                                                        env)  
                              #f  ))
        ((pair? pat)      ;(displayn "pair=" pat)
                          (if (pair? exp) 
                              (match (cdr pat) 
                                     (cdr exp) 
                                     (match (car pat) (car exp) env)  )
                              #f  ))
        (else             ;(displayn "unknown list element") 
                          #f)  )  ))

; for a var, no need to perform macro expansion since we assume it is already
; done during read.
; but after a pair we should check
; macros in transformers should NOT go through macro expansion

(define pn (lambda (a) (displayn "-->" a) a))

(load "pc-macro-transformers.sim")

(define make-exp-old (lambda (tem env)
  ;(displayn "make-exp  tem=[" tem "]  env=[" env "]")
  ;(define pn I)
  (define make (lambda (tem)
    (cond 
        ( (null? tem)      '() )
        ( (pat-var? tem)   (alist-lookup tem env) )
        ( (atom? tem)      tem  )
        ( (pair? tem)      (eval-macro (pn (cons (make (car tem)) 
                                                 (make (cdr tem))  ))))
        (else              (displayn "make-exp: unknown template element" tem) #f )  )  ))
  (make tem)  ))

(define make-exp (lambda (tem env)
  ;(displayn "make-exp  tem=[" tem "]  env=[" env "]")
  (cond 
        ( (null? tem)      '() )
        ( (pat-var? tem)   (alist-lookup tem env) )
        ( (atom? tem)      tem  )
        ( (pair? tem)      (eval-macro (cons (make-exp (car tem) env) 
                                             (make-exp (cdr tem) env)  )))
        (else              (displayn "make-exp: unknown template element" tem) #f )  )  ))

  
; make expression using positional values
; (add ?1 ?2) (3 4) -> (add 3 4)
;
; Use to trigger memory leak by internal define
;
(define make-expn (lambda (tem . ags)
  ;(displayn "make-expn  tem=[" tem "]  ags=[" ags "]")
  (define make (lambda (tem)
    (cond 
        ( (null? tem)      '() )
        ( (pat-var? tem)   (list-ref ags (var->ref tem)) )
        ( (atom? tem)      tem  )
        ( (pair? tem)      (cons (make (car tem)) 
                                 (make (cdr tem))  ))
        (else              (displayn "make-expn: unknown template element" tem) #f)  )  ))
  (make tem)  ))

(define make-expna (lambda (tem ags)
  (cond 
        ( (null? tem)      '() )
        ( (pat-var? tem)   (list-ref ags (var->ref tem)) )
        ( (atom? tem)      tem  )
        ( (pair? tem)      (cons (make-expna (car tem) args) 
                                 (make-expna (cdr tem) args)  ))
        (else              (displayn "make-expna: unknown template element" tem) #f)  )  ))

(define make-expn-keep (lambda (tem . args) (make-expna tem args)))

; macro is (pattern template)
;
(define macro-pat (lambda (macro) (car macro) ))
(define macro-tem (lambda (macro) (cadr macro) ))
(define macro-typ (lambda (macro) (caddr macro) ))
(define macro-mes (lambda (macro) (cadddr macro) ))

; patern is (key . rest)
;
(define pat-key (lambda (pat) (car pat) ))
(define pat-rest (lambda (pat) (cdr pat) ))

(define exp-tag (lambda (exp) (car exp)))

; an environment means we may be able to apply this macro
;
(define eval-macro-apply (lambda (exp trans env)
  (cond (env (displayn (macro-typ (car trans)) ":  " (macro-mes (car trans)))
             (make-exp (macro-tem (car trans)) env)  )
        (else (eval-macro-worker exp (cdr trans)))  )  ))

; see if there are any macros that can be applied
;
(define eval-macro-worker (lambda (exp trans)
  (cond ((null? trans) exp)                      ; no more translations
        ((atom? exp)   exp)                      ; we don't translate atoms
        ((eq? (pat-key (macro-pat (car trans))) 
              (exp-tag exp)  )                   ; tag matches
         (eval-macro-apply exp 
                           trans 
                           (match (macro-pat (car trans)) exp '())  ))
        (else (eval-macro-worker exp (cdr trans)))  )  )) ; try next

(define eval-macro-redo (lambda (exp trans new)
  (if (eq? new exp) 
      exp 
      (eval-macro-redoer new trans)  )  ))

(define eval-macro-redoer (lambda (exp trans)
  (eval-macro-redo exp trans (eval-macro-worker exp trans))  ))

; expand macros using transformers
;         
; old (define eval-macro (lambda (exp) (eval-macro-worker exp transformers) ))
(define eval-macro-exp (lambda (exp) (eval-macro-redoer exp transformers) ))
;(define x-eval (lambda (exp) (eval-macro-redoer exp x-trans) ))

(define eval-macro (lambda (exp)
      ;(display "do: (eval-macro ") (print exp) (display ") -> ")
  (cond ((atom? exp) exp)
        (else (eval-macro-exp (cons (eval-macro (car exp)) 
                                    (eval-macro (cdr exp))  ))))  ))

;(define  x-trans '(
;  ((aaa ?a) (zzz ?a))
;  ((bbb . ?a) (ccc . ?a))
;  ((ccc . ?a) (zzz . ?a))
;))

;(x '(aaa 2))
;(x '(aaa (aaa 2)))
;(x '(aaa (aaa (aaa 2))))
;(x '(aaa (aaa (aaa (aaa 2)))))
;(x '(aaa (bbb (aaa 2) (bbb (aaa 1) (bbb 2) 3))))

;(exit 1)

;;;;;;;;;; macro test area

(apply (eval1 'atom?) 12)

(delay 3)
(delay (car (cons "car" "cdr")))
(not 2)
(not #f)
(if #f "error" "ok")
(if 3 "ok" "error")
(if (not #f) "ok" "error")
(and 3)
(and #f)
(define x '(#f 3))
(and (car x) #f)
(and (car x) #t)

(exit 1)

;;;;;;;;;; benchmarking
; see old file circa 6/2/2012 for some pairs benchmarking data
;;;;;;;;;;

;(? 1 1)
;(? + '+)
;(? 0 '(+) )
;(? 1 '(+ 1) )
;(? 3 '(+ 1 2) )
;(? 6 '(+ 1 2 3) )
;(? 10 '(+ 1 2 3 4) )
;(? 4 '(inc 3) )
;(? 5 '(begin 1 (inc 2) (+ 2 3)) )
;(? #t '(and) )
;(? 2 '(and 2) )
;(? #f '(and (= 1 2) (= 3 4) (= 5 6)) )
;(? #f '(or) )
;(? 2 '(or 2) )
;(? #f '(or (= 1 2) (= 3 4) (= 5 6)) )
;(? 6 '(let ((x 3)) (+ x 3)) )
;(? 6 '(let* ((x 3)) (+ x 3)) )
;(? 7 '(let* ((x 3) (y 4)) (+ x y)) )

;;;;;;;;;; keep last

(display "Macros loaded.") (newline)
(display "Macros loaded.") (newline)

(cond ((eq? pc-test-count pc-test-stop) (displayn "Macro failed " pc-test-count "tests.") 
                                        (exit 1)  )
      (else '())  )

