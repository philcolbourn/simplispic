"Loading a Toy Scheme Macros..."
(define pc-scheme.mac #t)

;(define warn (lambda (mess name atom) (cons mess (cons name atom)) ))

; key-value pairs (key . value)

(define make-kvp (lambda (key val) (cons key val)))
(define kvp-key (lambda (kvp) (car kvp)))
(define kvp-val (lambda (kvp) (cdr kvp)))

; key-value lists (key value) - uses 1 extra pair

(define make-kvl (lambda (key val) (list key val)))
(define kvl-key (lambda (kvl) (car kvl)))
(define kvl-val (lambda (kvl) (cadr kvl)))

; associative list ((k . v) (k . v) ...)

(define make-alist (lambda (keys vals)
  (cond ((null? keys) (if (null? vals) '() (make-alist "Not enough keys for values" vals)))
        ((atom? keys) (list (make-kvp keys vals)) )  ; key=(v v ...)
        ((null? vals) (list (make-kvp (car keys) '())
                            (make-alist (cdr keys) '())) )  ; missing values are ()
        (else (list (make-kvp (car keys) (car vals))
                    (make-alist (cdr keys) (cdr vals)))  )) 
))

(define extend-alist (lambda (kvp alst) (cons kvp alst)))

(define alist-assoc (lambda (key alst)
  ;(displayn "alist-assoc  key=[" key "]  alst=[" alst "]")
  (cond ((null? alst) #f)
        ((eq? key (kvp-key (car alst))) 
         ;(peek "found key->" (car alst))
         (car alst))
        (else (alist-assoc key (cdr alst)))  )))

(define alist-lookup (lambda (key alst)
  ;(displayn "alist-lookup  key=[" key "]  alst=[" alst "]")
  (cond ((null? alst) key)
        ((eq? key (kvp-key (car alst))) (kvp-val (car alst)))
        (else (alist-lookup key (cdr alst)))  )))
  
(define assocv2 (lambda (sym env)
  (cond ((null? env) #f)
        (else
          ((lambda (kvp)
                   (if kvp 
                       kvp 
                       (assoc sym (cdr env))  ))
           (alist-assoc sym (car env)))  ))))

(define assoc (lambda (sym env)
  (cond ((null? env) #f)
        (else
          (define kvp (alist-assoc-fail sym (car env) #f)) 
          (if kvp 
              kvp 
              (assoc sym (cdr env))  )))))

; (and) -> #t
; (and a) -> a
; (and a1 a2) -> (if a1 a2 #f)
; (and a1 a2 a3) -> (if a1 (if a2 a3 #f) #f)
;($s $n)

(define indent (lambda (n)
  (if (= n 0) '() (progn (print "  ") (indent (- n 1))))  ))

(define indent-level 0)

; display args separated by a leading space 

(define displayn (lambda args
  (if (null? args) 
      (display "\n") 
      (progn 
        (display " ")
        (display (car args)) 
        (apply displayn (cdr args))  ))))

(displayn 1)
(displayn 1 "2")
(displayn 1 "" "2" "23" "234" "2345" 't 'th 'thr 'three)
(displayn 1 2 'three 4)
;(exit 1)

(define peek (lambda (mess . args)
  ;(indent indent-level) 
  (display mess)
  (displayn args)  ))

; define or match a symbol

(define match-or-define-variable (lambda (kvp var exp env)
  ;(displayn "modv: kvp=[" kvp "]  var=[" var  "]  exp=[" exp  "]  env=[" env "]")
  (cond (kvp  ;(displayn "  variable found var=" var "]  val=[" (kvp-val kvp) "]")
              (if (equal? (kvp-val kvp) exp) env #f)
              ;(if (match? (kvp-val kvp) exp env) env #f)     ; FIXME: match?
        )     
        (else (extend-alist (make-kvp var exp) env))  )))

; does template match expression given environment

(define var? (lambda (tem)
  (if (symbol? tem)
      (if (eq? (symbol-ref tem 0) #\?) 
          (if (> (symbol-length tem) 1) #t #f) 
          #f  )
      #f  )
))

(equal? '() '())
(equal? '(1) '())
(equal? 1 1)
(equal? 'a 'a)
(equal? 'abcd 'abcd)
(equal? "a" "a")
(equal? "abcd" "abcd")
(equal? '(1 a) '(1 a))
(equal? '(1 (2 () 3) a) '(1 (2 () 3) a))

(define match (lambda (tem exp env)
  ;(displayn "match tem=[" tem "]  exp=[" exp "]  env=[" env "]")
  (cond 
        ((eq? env #f) #f) 
        ;((null? tem)  ;(displayn "END OF TEMPLATE exp=" exp) 
        ;              (if (null? exp) env #f)  )
        ;((null? exp)  ;(displayn "END OF EXPRESSION tem=" tem)
        ;              #f  )
        ; SICP place
        ;((eq? tem exp) env)
        ((equal? tem exp) env)
        ((var? tem)   ;(displayn "symbol=" tem)
                      (match-or-define-variable (alist-assoc tem env) tem exp env)  )
        ; my place for atom?
        ;((atom? tem)  ;(displayn "atom=" tem)
        ;              (if (equal? tem exp) env #f)  )
        ((pair? tem)  ;(displayn "pair=" tem)
                      (if (pair? exp) 
                          (match (cdr tem) 
                                 (cdr exp) 
                                 (match (car tem) (car exp) env)  )
                          #f  ))
        (else         ;(displayn "unknown list element") 
                      #f)  )
))


(match '() '() '())
(match '(1) '() '())
(match '() '(1) '())
(match '(1) '(1) '())
(match '(1) '(2) '())
(match '(1 2 "3" (4 #\5 () 7) (8)) '(1 2 "3" (4 #\5 () 7) (8)) '())
(match '(?x) '(2) '())
(match '(1 ?x) '(1 ("this is x")) '())
(match '(1 ?x (?x 2)) '(1 ("x") (("x") 2)) '())
(match '(1 ?x (?x 2)) '(1 ("x") (("y") 2)) '())

(match '(define (?name . ?args) ?body) 
       '(define (inc x) (+ x 1)) 
       '()  )

(match '?nil '() '())
;(exit 1)

(define make-exp (lambda (tem env)
  ;(displayn "make-exp  tem=[" tem "]  env=[" env "]")
  (cond 
        ((null? tem) '())
        
        ((var? tem)  ;(displayn "symbol=" tem)
                     (eval-macro (alist-lookup tem env))
         ;(define kvp (alist-assoc-fail tem env #f))
         ;(display "kvp=" kvp)
         ;(if kvp                        ; symbol found in env
         ;    (eval-macro (kvp-val kvp))
         ;    tem)
           )
             
        ((atom? tem)  ;(displayn "atom=" tem)
                      tem  )
        
        ((pair? tem)  ;(displayn "pair=" tem)
         ; do i need eval-macro here as well?
         (cons 
           (eval-macro (make-exp (car tem) env)) 
           (eval-macro (make-exp (cdr tem) env))  ))

        (else (display "unknown\n") #f)  )
))

(define transformers '(
  ;(nil ())
  ((define (?n . ?a) . ?b) (define ?n (lambda . ?a) . ?b)) 
  ((begin . ?b) (progn . ?b)) 
  ((inc ?a) (+ ?a 1)) 
  ((dec ?a) (1 ?a 1)) 
  ((not ?e) (if ?e #f #t))
  ((and) #t)  
  ((and ?e) ?e) 
  ((and ?e1 . ?e2) (if ?e1 (and . ?e2) #f)) 
  ((or) #f)  
  ((or ?e) ?e) 
  ((or ?e1 . ?e2) (if ?e1 #t (or . ?e2))) 
  ((let  ((?f ?e)) . ?b) ((lambda (?f) . ?b) ?e))
  ((let* ((?f ?e)) . ?b) ((lambda (?f) . ?b) ?e))
  ((let* ((?f ?e) . r) . ?b) ((lambda (?f) (let* ?r . ?b)) ?e))
  ((cons-stream ?a ?b) (cons ?a (delay ?b)))

))

;(define make-trans-env (lambda (env)
;  (if (null? env) 
;      '() 
;      (cons 
;        (make-kvp (car env) '*UNDEF*) 
;        (make-trans-env (cdr env))  ))  ))

(define eval-macro-worker (lambda (exp trans)
  ;(displayn "emw exp=" exp)
  (cond ((null? trans) exp)
        ((atom? exp) exp)
        ((not (eq? (caaar trans) (car exp))) (eval-macro-worker exp (cdr trans)))
        (else  ; 
          ;(displayn "emw trans=" trans)
          ;(displayn "emw tem=" (caar trans))
          ;(define env (match (caar trans) exp (make-trans-env (caddar trans))))
          (define env (match (caar trans) exp '()))
          ;(displayn "emw env=" env)
          (if env 
              (progn
                ;(displayn "Transform " exp " -> ")
                (define nexp (make-exp (cadar trans) env))
                ;(print nexp) (newline)
                (eval-macro-worker nexp transformers) 
                ;nexp 
              ) 
              (progn
                ;(display "Try next transformer ") (print (cdr trans)) (newline)
                (eval-macro-worker exp (cdr trans))  ))  ; try next transform
            )              )  ))
            
(define eval-macro (lambda (exp) (eval-macro-worker exp transformers)))
;(define eval-macro (lambda (exp) exp))

(define ?count 0)  ;; count errors

(define ? (lambda (expect exp)
  (displayn "test exp=" exp "->" expect)
  (define result (eval1 exp))  ;; FIXME: this is bad
  ;(let ((result (eval1 exp)))
    (if (equal? result expect)
      (progn
        (display "  pass\n")
        #t  )
      (progn
        (set! ?count (+ ?count 1))
        (displayn "FAIL! Got" result)
        (if (= ?count 5) (exit) #f )  )  )
  ;)   
))

;(? 5 '(+ 2 3))
;(? 5 '(+ 2 3 1))
; org (don't process atoms) (remove nil () ()) (match tag of list) (no macro) (macro)
;     (alist-assoc-fail) (eliminate assoc defines) | SICP-like version
;     SICP version with eq instead of equal
;     SICP version with equal
1  ; 2580 23 232 23 8 23 23 | 23 23
+  ; 2580 23 23 23 8 23 23 | 23 23
(+)  ; 9978 (+7398) 4928 4808 823 32 823 823 | 823 823
(+ 1)  ; 12582 (+2604) 4975 4855 870 64 870 870 | 870 870
(+ 1 2)  ; 15186 (+2604) 5022 4902 917 96 917 917 | 917 917
(+ 1 2 3)  ; 17790 (+2604) 5069 4949 964 128 964 964 | 964 964
(+ 1 2 3 4)  ; 20394 (+2604) 5116 4996 1011 160 1011 1011 | 1011 1011

(inc 3)  ; ... 3360 3378 | 3299 3253
(begin 1 (inc 2) (+ 2 3))  ; ... 7270 7306 | 7132 7046
(and)  ; ... 586 589 | 565 525
(and 2)  ; ... 1129 1144 | 1052 978
(and (= 1 2) (= 3 4) (= 5 6))  ; ... 21921 22050 | 21282 20992
;(or)
;(or 2)
;(or (= 1 2) (= 3 4) (= 5 6))
;(let ((x 3)) (+ x 3))
(let* ((x 3)) (+ x 3))  ; ... 10436 10496 | 10261 10197
(let* ((x 3) (y 4)) (+ x y))  ; ... 23892 20478 | died died

(exit 1)

; keep last

(display "Macros loaded.") (newline)

(exit 1)

