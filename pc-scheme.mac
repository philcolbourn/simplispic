"Loading a Toy Scheme Macros..."

(define pc-scheme.mac #t)

;(define warn (lambda (mess name atom) (cons mess (cons name atom)) ))
;
;can we keep record of defines so we know what file some function came from?
;maybe modify define to record filename in env
;
;(define requires (lambda (dep)
;  (if dep (displayn dep "loaded.") (load dep))))

;(requires "pc-adt-kv.sim")

; define or match a symbol

(define match-or-define-variable (lambda (kvp var exp env)
  ;(displayn "modv: kvp=[" kvp "]  var=[" var  "]  exp=[" exp  "]  env=[" env "]")
  (cond (kvp  ;(displayn "  variable found var=" var "]  val=[" (kvp-val kvp) "]")
              (if (equal? (kvp-val kvp) exp) env #f)
              ;(if (match? (kvp-val kvp) exp env) env #f)     ; FIXME: match?
        )     
        (else (extend-alist (make-kvp var exp) env))  )))


(define var? (lambda (tem)
  (if (symbol? tem)
      (if (eq? (symbol-ref tem 0) #\?) 
          (if (int> (symbol-length tem) 1) #t #f) 
          #f  )
      #f  )  ))

(define char->num '(
  (#\0 . 0)
  (#\1 . 1)
  (#\2 . 2)
  (#\3 . 3)
  (#\4 . 4)
  (#\5 . 5)
  (#\6 . 6)
  (#\7 . 7)
  (#\8 . 8)
  (#\9 . 9)
))

; hack to convert a pattern variable to a number
;
(define var->ref (lambda (var)
  (if (symbol? var)
      (if (eq? (symbol-ref var 0) #\?) 
          (alist-lookup (symbol-ref var 1) char->num)
          #f  )
      #f  )  ))

; does template match expression given environment

(define match (lambda (pat exp env)
  ;(displayn "match pat=[" pat "]  exp=[" exp "]  env=[" env "]")
  (cond 
        ((eq? env #f) #f)
        ; SICP place
        ;((eq? pat exp) env)
        ((equal? pat exp) env)
        ((var? pat)   ;(displayn "var=" pat)
                      (match-or-define-variable (alist-assoc pat env) 
                                                pat 
                                                exp 
                                                env)  )
        ((pair? pat)  ;(displayn "pair=" pat)
                      (if (pair? exp) 
                          (match (cdr pat) 
                                 (cdr exp) 
                                 (match (car pat) (car exp) env)  )
                          #f  ))
        (else         ;(displayn "unknown list element") 
                      #f)  )
))

; for a var, no need to perform macro expansion since we assume it is already
; done during read.
; but after a pair we should check
; macros in transformers should NOT go through macro expansion

(define pn (lambda (a) (displayn "-->" a) a))

(load "pc-macro-transformers.sim")

(define make-exp-old (lambda (tem env)
  ;(displayn "make-exp  tem=[" tem "]  env=[" env "]")
  ;(define pn I)
  (define make (lambda (tem)
    (cond 
        ( (null? tem)  '() )
        ( (var? tem)   (alist-lookup tem env) )
        ( (atom? tem)  tem  )
        ( (pair? tem)  (eval-macro (pn (cons (make (car tem)) 
                                             (make (cdr tem))  ))))
        (else          (displayn "make-exp: unknown template element" tem) #f )  )  ))
  (make tem)  ))

(define make-exp (lambda (tem env)
  ;(displayn "make-exp  tem=[" tem "]  env=[" env "]")
  (cond 
        ( (null? tem)  '() )
        ( (var? tem)   (alist-lookup tem env) )
        ( (atom? tem)  tem  )
        ( (pair? tem)  (eval-macro (cons (make-exp (car tem) env) 
                                         (make-exp (cdr tem) env)  )))
        (else          (displayn "make-exp: unknown template element" tem) #f )  )  ))

  
; make expression using positional values
; (add ?1 ?2) (3 4) -> (add 3 4)
;
; Use to trigger memory leak by internal define
;
(define make-expn (lambda (tem . ags)
  ;(displayn "make-expn  tem=[" tem "]  ags=[" ags "]")
  (define make (lambda (tem)
    (cond 
        ( (null? tem)  '() )
        ( (var? tem)   (list-ref ags (var->ref tem)) )
        ( (atom? tem)  tem  )
        ( (pair? tem)  (cons (make (car tem)) 
                             (make (cdr tem))  ))
        (else          (displayn "make-expn: unknown template element" tem) #f)  )  ))
  (make tem)  ))

(define make-expna (lambda (tem ags)
  (cond 
        ( (null? tem)  '() )
        ( (var? tem)   (list-ref ags (var->ref tem)) )
        ( (atom? tem)  tem  )
        ( (pair? tem)  (cons (make-expna (car tem) args) 
                             (make-expna (cdr tem) args)  ))
        (else          (displayn "make-expna: unknown template element" tem) #f)  )  ))

(define make-expn-keep (lambda (tem . args) (make-expna tem args)))

; macro is (pattern template)
;
(define macro-pat (lambda (macro) (car macro) ))
(define macro-tem (lambda (macro) (cadr macro) ))

; patern is (key . rest)
;
(define pat-key (lambda (pat) (car pat) ))
(define pat-rest (lambda (pat) (cdr pat) ))

(define exp-tag (lambda (exp) (car exp)))

; an environment means we may be able to apply this macro
;
(define eval-macro-apply (lambda (exp trans env)
  (if env
      (make-exp (macro-tem (car trans)) env)
      (eval-macro-worker exp (cdr trans))  )  ))

; see if there are any macros that can be applied
;
(define eval-macro-worker (lambda (exp trans)
  (cond ((null? trans) exp)                      ; no more translations
        ((atom? exp)   exp)                      ; we don't translate atoms
        ((eq? (pat-key (macro-pat (car trans))) 
              (exp-tag exp)  )                   ; tag matches
         (eval-macro-apply exp 
                           trans 
                           (match (macro-pat (car trans)) 
                                  exp 
                                  '()  )))
        (else (eval-macro-worker exp (cdr trans)))  )  ))

; expand macros using transformers
;         
(define eval-macro (lambda (exp) (eval-macro-worker exp transformers) ))


;;;;;;;;;; macro test area

;;;;;;;;;; benchmarking
; see old file circa 6/2/2012 for some pairs benchmarking data
;;;;;;;;;;

;(? 1 1)
;(? + '+)
;(? 0 '(+) )
;(? 1 '(+ 1) )
;(? 3 '(+ 1 2) )
;(? 6 '(+ 1 2 3) )
;(? 10 '(+ 1 2 3 4) )
;(? 4 '(inc 3) )
;(? 5 '(begin 1 (inc 2) (+ 2 3)) )
;(? #t '(and) )
;(? 2 '(and 2) )
;(? #f '(and (= 1 2) (= 3 4) (= 5 6)) )
;(? #f '(or) )
;(? 2 '(or 2) )
;(? #f '(or (= 1 2) (= 3 4) (= 5 6)) )
;(? 6 '(let ((x 3)) (+ x 3)) )
;(? 6 '(let* ((x 3)) (+ x 3)) )
;(? 7 '(let* ((x 3) (y 4)) (+ x y)) )

;;;;;;;;;; keep last

(display "Macros loaded.") (newline)
(display "Macros loaded.") (newline)

(cond ((eq? pc-test-count pc-test-stop) (displayn "Macro failed " pc-test-count "tests.") 
                                        (exit 1)  )
      (else '())  )

