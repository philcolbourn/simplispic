
(define transformers '(
  ( (define (?n . ?a) . ?b) (define ?n (lambda ?a . ?b)) 'info "expanding define to lambda form") 
  ( (delay ("req" atom? ?a)) ?a         'warn "can't delay a constant"       )
  ( (delay . ?e)       (lambda () . ?e) 'info "converting delay into lambda" )
  ( (begin . ?b)       (progn . ?b)     'warn "FIXME: make 'begin' normal"   ) 

  ( (inc ?a) (+ ?a 1) 'info "test" ) 
  ( (dec ?a) (1 ?a 1) 'info "test" ) 

  ; hard: to do (cond ((eq? a b) => (do-something)) ... (else (something-else)))
  ;( (cond ((?p => ?a) . ?r) (cond ((?p ?a) . )) )

  ( (and)                   #t                      'warn "'and' with no arguments"          )  
  ( (and #f)                #f                      'warn "'and' argument evaluates false"   )  
  ( (and ("req" atom? ?x))  ?x                      'warn "'and' argument evaluates as true" )  
  ( (and ?e)                ?e                      'info "'and' with one argument"          ) 
  ( (and ?e1 . ?e2)         (if ?e1 (and . ?e2) #f) 'info "converting 'and' to 'if's"        ) 

  ( (or)                   #f                      'warn "'or' with no argument"           )  
  ( (or #f)                #f                      'warn "'or' argument evaluates false"   )  
  ( (or ("req" atom? ?x))  ?x                      'warn "'or' argument evaluates as true" )  
  ( (or ?e)                ?e                      'warn "'or' with one argument"          ) 
  ( (or ?e1 . ?e2)         (if ?e1 ?e1 (or . ?e2)) 'info "converting 'or' to 'if's"        )
      ; r4rstest not (if ?e1 >#t< ...)

  ( (not #f)               #t            'warn "'not' expresion evaluates true"   )
  ( (not ("req" atom? ?a)) #f            'warn "'not' expression evaluates false" )
  ( (not ?e)               (if ?e #f #t) 'info "converting 'not' to 'if'"         )

  ( (if #f ?c ?a)               ?a 'warn "consequent is unreachable"  )
  ( (if ("req" atom? ?x) ?c ?a) ?c 'warn "alternative is unreachable" )
  ( (if ?e #t #f)               ?e 'warn "'if' not required"          )
  
  ; (let->form ((v1 e1) (v2 e2) ...)) 
  ;   --> (v1 v2 ...)
  ;
  ( (let->form ()            ) ()                    'info "no more let formals"      )
  ( (let->form ((?f ?e) . ?r)) (?f . (let->form ?r)) 'info "make list of let formals" )

  ; (let->exps ((v1 e1) (v2 e2) ...)) 
  ;   --> (e1 e2 ...)
  ;
  ( (let->exps ()            ) ()                    'info "no more let expressions"      )
  ( (let->exps ((?f ?e) . ?r)) (?e . (let->exps ?r)) 'info "make list of let expressions" )

  ; (let ((v1 e1) (v2 e2) ...) . ?b) 
  ;   --> ((lambda (v1 v2 ...) . ?b) e1 e2 ...)
  ;
  ( (let () . ?b) ((lambda () . ?b))                              
      'info "convert let with no argument to lambda application" )
  ( (let ?a . ?b) ((lambda (let->form ?a) . ?b) . (let->exps ?a)) 
      'info "convert let to lambda application"                  )

  ; let* version 1
  ; let* -> lambdas - this should be faster
  ( (let* () . ?b)             ((lambda () . ?b))                'FIXME "no message")
  ( (let* ((?f ?e) . ?r) . ?b) ((lambda (?f) (let* ?r . ?b)) ?e) 'FIXME "no message")

  ;; let* version 2
  ;; let* -> lets -> lambdas
  ;;
  ;;( (let* () . ?b)               (let () . ?b)                  )
  ;;( (let* ((?f ?e) . ?r) . ?b)   (let ((?f ?e)) (let* ?r . ?b)) )

  ; (letrec->define ((v1 e1) (v2 e2) ...) . b)
  ;   --> ((define v1 e1) (define v2 e2) . b)
  ;
  ( (letrec->define (?d) . ?b)      ((define . ?d) (let () . ?b))              'FIXME "no message")
  ( (letrec->define (?d . ?r) . ?b) ((define . ?d) . (letrec->define ?r . ?b)) 'FIXME "no message")

  ; (letrec ((v e) ...) . b) 
  ;   --> (let () (define v e) ... (let () . b))
  ; 
  ( (letrec () . ?b) (let () . ?b)                       'FIXME "no message")
  ( (letrec ?v . ?b) (let () . (letrec->define ?v . ?b)) 'FIXME "no message")
  
  ( (cons-stream ?a ?b) (cons ?a (delay ?b)) 'info "expanding cons-stream")

  ( (zero? ?e)     (eq? ?e 0) 'info "simplified zero?")
  ( (even? ?e)     (and (number? ?e) (eq? (remainder ?e 2) 0)) 'info "simplified even?")
  ( (odd?  ?e)     (and (number? ?e) (not (eq? (remainder ?e 2) 1))) 'info "simplified odd?")
  ( (positive? ?e) (and (number? ?e) (> ?e 0)) 'info "expanding positive?")
  ( (negative? ?e) (and (number? ?e) (< ?e 0)) 'info "expanding negative?")
  ( (+ve? ?e)      (positive? ?e) 'info "simplified +ve?")
  ( (-ve? ?e)      (negative? ?e) 'info "simplified -ve?")
  ( (abs ?e)       (and (number? ?e) (if (>= ?e 0) ?e (- ?e))) 'info "expanding abs")
))


