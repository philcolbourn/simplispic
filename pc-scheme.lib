"Loading a Toy Scheme Library..."
(define pc-scheme.lib #t)

;; some necessary symbols

;; alias primitives with nicer names
;(define + iadd)
(define + (lambda args
  (if (null? args) 0 (iadd (car args) (apply + (cdr args))  ))  ))
;(define - isub)
(define - (lambda args
  (if (null? args) 0 (isub (car args) (apply + (cdr args))  ))  ))
(define * imul)
; FIXME: do same for * and / etc.
(define / idiv)
(define remainder imod)
(define modulo imod)
(define % imod)
(define eq? eqp)
(define equal? equalp)
(define list? listp)  ; FIXME: can list? be written here?
(define atom? atomp)
(define pair? pairp)
(define null? nullp)
(define char? charp)
(define < ilt)
(define > igt)
(define <= ilte)
(define >= igte)
(define = ieq)
(define print printa)
(define procedure? procp)
(define exit exita)
(define number? numberp)
(define symbol? symbolp)
(define string? stringp)
(define set-car! set_car)
(define set-cdr! set_cdr)
(define symbol->string sym_to_str)
(define string-ref str_ref)
(define symbol-ref str_ref)
(define string-length string_length)
(define symbol-length string_length)

(define caar (lambda (a) (car (car a))) )
(define cadr (lambda (a) (car (cdr a))) )
(define cdar (lambda (a) (cdr (car a))) )
(define cddr (lambda (a) (cdr (cdr a))) )

(define caaar (lambda (a) (car (car (car a)))) )
(define caadr (lambda (a) (car (car (cdr a)))) )
(define cadar (lambda (a) (car (cdr (car a)))) )
(define caddr (lambda (a) (car (cdr (cdr a)))) )

(define cdaar (lambda (a) (cdr (car (car a)))) )
(define cdadr (lambda (a) (cdr (car (cdr a)))) )
(define cddar (lambda (a) (cdr (cdr (car a)))) )
(define cdddr (lambda (a) (cdr (cdr (cdr a)))) )

(define caaaar (lambda (a) (car (car (car (car a))))) )
(define caaadr (lambda (a) (car (car (car (cdr a))))) )
(define caadar (lambda (a) (car (car (cdr (car a))))) )
(define caaddr (lambda (a) (car (car (cdr (cdr a))))) )

(define cadaar (lambda (a) (car (cdr (car (car a))))) )
(define cadadr (lambda (a) (car (cdr (car (cdr a))))) )
(define caddar (lambda (a) (car (cdr (cdr (car a))))) )
(define cadddr (lambda (a) (car (cdr (cdr (cdr a))))) )


(define cdaaar (lambda (a) (cdr (car (car (car a))))) )
(define cdaadr (lambda (a) (cdr (car (car (cdr a))))) )
(define cdadar (lambda (a) (cdr (car (cdr (car a))))) )
(define cdaddr (lambda (a) (cdr (car (cdr (cdr a))))) )

(define cddaar (lambda (a) (cdr (cdr (car (car a))))) )
(define cddadr (lambda (a) (cdr (cdr (car (cdr a))))) )
(define cdddar (lambda (a) (cdr (cdr (cdr (car a))))) )
(define cddddr (lambda (a) (cdr (cdr (cdr (cdr a))))) )

; more primitives
;
(define newline (lambda () (display "\n")))
(define else #t)  ;; should be a keyword in cond
(define list (lambda args args))

; not does not work as macro in rxrs test!
;
(define not (lambda (a) (if a #f #t)))

; identity procedure
;
(define I (lambda (x) x))


;(define max (lambda args
;  (cond ((null? args) if (and (number? (car args)) ())
;))

(define match-taglist (lambda (lst tag)
  (if (not (pair? lst) ) 
      #f
      (eq? (car lst) tag)  )))

(define make-lambda (lambda (form body)
  (cons 'lambda (cons form body))  ))

(load "pc-adt-kv.lib")
(load "pc-adt-alist.lib")

; load macros

(load "pc-scheme.mac")

; needs 'or'
(define boolean? (lambda (x) (or (eq? x #t) (eq? x #f)) ))


; FIXME: this need to go after all RxRS is defined

; closure ADT
;   (closure <proc> env G)
;
(define (closure? c) (match-taglist c 'closure))
(define (closure-proc c) (cadr c))
(define (closure-env c) (cdddr c))

; use implementation knowledge to get null-environment
;
(define null-environment (closure-env (lambda () 'nothing)))
print null-environment
;(exit 1)

;; simplispic version of equal?
(define _equal? (lambda (a b)
  (if (eq? a b) 
      #t
      (if (and (pair? a) (pair? b) ) 
          (if (_equal? (car a) (car b)) 
              (_equal? (cdr a) (cdr b)) 
              #f  )
          #f  )  )  ))


; force a promise - force is not a special form

(define force (lambda (p) (p))) 
(define d (delay (cons 1 d)))
d
(? '(lambda () (cons 1 d)) '(cadr d))  ;; not evaluated yet
(? '1 '(car (force d)))                ;; now car should be 1
(force d)
(cdr (force d))
(? '(lambda () (cons 1 d)) '(caddr (force d)))  ;; 3rd should be promise
(? '1 '(car (force (cdr (force d)))))          ;; 
;(?all ??  (lambda (x) (force (delay x)))  )


;; stream-cdr is not a special form

(define stream-cdr (lambda (p) (force (cdr p)) ))

;; show n elements of a stream

(define show-stream (lambda (s n)
  (if (eq? n 0)
    '(...)         ;; could not think of a better ending
    (cons (car s)
          (show-stream (stream-cdr s) (- n 1))  )  )))
    
(define ss show-stream)

(define list-tail (lambda (x k)
  (if (zero? k)
      x
      (list-tail (cdr x) (- k 1))  )))

(define (list-ref a n)
  (cond ((null? a) ())
        ((eq? n 0) (car a))
        (else (list-ref (cdr a) (- n 1)))  ))

(define make-promise
  (lambda (proc)
    (let ((result-ready? #f)
          (result #f))
      (lambda ()
        (if result-ready?
            result
            (let ((x (proc)))
              (if result-ready?
                  result
                  (begin (set! result-ready? #t)
                         (set! result x)
                         result  )  )))))))
;make-promise

;(define x (make-promise (lambda () (+ 2 3))))
;x
;(force x)
;(exit 1)

;; an expected test

(define (fact n)
  (if (= n 0)
      1
      (* n (fact (- n 1)))  )  )

(? 1 '(fact 0))
(? 1 '(fact 1))
(? 120 '(fact 5))

;;;;;;;;;; tests
           
;; a version of car, cdr and cons using lambda

(define kar (lambda (z) (z (lambda (p q) p))))
(define kdr (lambda (z) (z (lambda (p q) q))))
(define kons (lambda (x y) (lambda (m) (m x y))))

;; another version that is easier to understand but needs if

(define kons2 (lambda (a b) (lambda (m) (if (eq? m 1) a b))))
(define kar2 (lambda (x) (x 1)))
(define kdr2 (lambda (x) (x 2)))

; is atm a member of an improper list?

(define (member-imp? atm lst)
  (cond ((null? lst) #f)
        ((eq? atm (car lst)) #t)
        ((eq? atm (cdr lst)) #t)
        (else (member-imp? atm (cdr lst)))  ))
        
(define pr (lambda (a)
  (if (atom? a)
      (print a)
      (progn (print \() (pr (car a)) (pr (cdr a)) (print \)))  )
))

;(define eval-cond (lambda (conds bindings)
;  (if ((eval (car (car conds)) bindings)
;      (eval (car (cdr (car conds))) bindings))
;      (eval-cond (cdr conds) bindings)  )  ))

; various list implementations
;
(? '(1 2 3) '(list 1 2 (+ 1 2)))
(define pc-list3 (lambda (first . rest) (cons first rest) ) )

(define (_append a b)
  (cond ((null? a) b)
        ((null? b) a)
        (else (cons (car a) (_append (cdr a) b))  )  ))

(define (append . args)
  (cond ((null? args) '())
        ((null? (cdr args)) (car args) )
        (else (_append (car args) (apply append (cdr args))) )  ))


(? '(1 2) '(_append '(1 2)))
;(exit 2)
(? '(1 2) '(_append '(1 2) '()))
(? '(1 2) '(_append '() '(1 2)))
(? '(1 2 3 4) '(_append '(1 2) '(3 4)))
(? '(1 2 . 3) '(_append '(1 2) 3))
(? '(1 2 3 . 4) '(_append '(1 2) '(3 . 4)))

            
(let () (print 1) )
;no good(let* () (print 1) )
(let* ((a 1)) (print a) )
(let* ((a 1) (b (+ a 1))) (print b) )
(let* ((a 1) (b (+ a 2))) (print a) (print b) )

(define (reverse a)
  (if (null? a)
     '()
     (append (reverse (cdr a)) (list (car a)) )  ))
     
(define (gcd a b)
  (if (= b 0) a
      (gcd b (modulo a b))))
      
(? 1 '(gcd 1 2))      
(? 1 '(gcd 1 9))      
(? 9 '(gcd (* 7 9) (* 5 9)))      

(define (gcd-euclid a b)
  (if (= b 0)
      a
      (if (> b a) 
          (gcd-euclid (- b a) a) 
          (gcd-euclid (- a b) b)  )))
(? 1 '(gcd-euclid 1 2))      
(? 1 '(gcd-euclid 1 9))      
(? 9 '(gcd-euclid (* 7 9) (* 5 9)))      

(define (for-each proc list)
  (cond ((null? list) "done")
        (else (proc (car list))
              (for-each proc (cdr list) )  )))
;(? '(1 4 9) '(for-each (lambda (x) (printerr (* x x))) '(1 2 3)))

; another member?
(define (member? x list)
     (cond ((null? list) #f)
           ((not (list? list)) #f)
           ((equal? x (car list)) #t)
           (else   (member? x (cdr list)))  ))
           
(define (member x lst)
  (cond ((null? lst) #f)
        ((equal? (car lst) x) lst)
        (else (member x (cdr lst)))  ))

(define (for-each f lst)
	(if (not (null? lst))
    (begin
	    (f (car lst))
	    (for-each f (cdr lst))  )
	  '()  ))

(define (map-list f l)
  (if (null? l)
    '()
     (cons (f (car l)) (map-list f (cdr l)) ) ))

; FIXME: not really map

(define map map-list)

;; convert procedures into cps form
;(define (cps-prim f)
; (lambda args
;  (let ((r (reverse args)))
;   ;(print "r=")
;   ;(print r)
;   ((car r) (apply f
;             (reverse (cdr r))))))  )

;(define *& (cps-prim *))
;(define +& (cps-prim +))
;(+& 2 3 (lambda (x) (print x)))

; FIXME: no map-car

;(define (map f . a*)
;  (let
;    ((carof
;       (lambda (a)
;         (map-car car a)))
;     (cdrof
;       (lambda (a)
;         (map-car cdr a)))
;     (_map
;       (lambda (a* r)
;         (cond ((null? (car a*)) (reverse r))
;           (else (_map (cdrof a*)
;                 (cons (apply f (carof a*)) r)))))))
;    (cond ((null? a*)
;        (bottom '(too few arguments to map)))
;      (else (_map a* '())))))

(load "pc-r4rstest.sim")

;;;;;;;;;; keep last
;
(if (> ?count 0)
  (displayn "Error: Toy library failed verification tests\n" "errors=" ?count)
  (displayn "Note: Toy library passed verification tests\n")  )

