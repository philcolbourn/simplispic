"Loading a Toy Scheme Library..."
(define pc-scheme.lib #t)

;; some necessary symbols
;(define '. '.)  ; what is this for?

;; alias primitives with nicer names
;(define + iadd)
(define + (lambda args
  (if (null? args) 
      0 
      (iadd (car args) 
            (apply + (cdr args))  ))))
;(define - isub)
(define - (lambda args
  (if (null? args) 0 (isub (car args) (apply + (cdr args))))  ))
(define * imul)
(define / idiv)
(define modulo imod)
(define % imod)
(define eq? eqp)
(define equal? equalp)
(define list? listp)
(define atom? atomp)
(define pair? pairp)
(define null? nullp)
(define char? charp)
(define < ilt)
(define > igt)
(define <= ilte)
(define >= igte)
(define = ieq)
(define print printa)
(define procedure? procp)
(define exit exita)
(define number? numberp)
(define symbol? symbolp)
(define string? stringp)
(define set-car! set_car)
(define set-cdr! set_cdr)
(define symbol->string sym_to_str)
(define string-ref str_ref)
(define symbol-ref str_ref)
(define string-length string_length)
(define symbol-length string_length)

(define caar (lambda (a) (car (car a))) )
(define cadr (lambda (a) (car (cdr a))) )
(define cdar (lambda (a) (cdr (car a))) )
(define cddr (lambda (a) (cdr (cdr a))) )

(define caaar (lambda (a) (car (car (car a)))) )
(define caadr (lambda (a) (car (car (cdr a)))) )
(define cadar (lambda (a) (car (cdr (car a)))) )
(define caddr (lambda (a) (car (cdr (cdr a)))) )

(define cdaar (lambda (a) (cdr (car (car a)))) )
(define cdadr (lambda (a) (cdr (car (cdr a)))) )
(define cddar (lambda (a) (cdr (cdr (car a)))) )
(define cdddr (lambda (a) (cdr (cdr (cdr a)))) )

(define caaaar (lambda (a) (car (car (car (car a))))) )
(define caaadr (lambda (a) (car (car (car (cdr a))))) )
(define caadar (lambda (a) (car (car (cdr (car a))))) )
(define caaddr (lambda (a) (car (car (cdr (cdr a))))) )

(define cadaar (lambda (a) (car (cdr (car (car a))))) )
(define cadadr (lambda (a) (car (cdr (car (cdr a))))) )
(define caddar (lambda (a) (car (cdr (cdr (car a))))) )
(define cadddr (lambda (a) (car (cdr (cdr (cdr a))))) )


(define cdaaar (lambda (a) (cdr (car (car (car a))))) )
(define cdaadr (lambda (a) (cdr (car (car (cdr a))))) )
(define cdadar (lambda (a) (cdr (car (cdr (car a))))) )
(define cdaddr (lambda (a) (cdr (car (cdr (cdr a))))) )

(define cddaar (lambda (a) (cdr (cdr (car (car a))))) )
(define cddadr (lambda (a) (cdr (cdr (car (cdr a))))) )
(define cdddar (lambda (a) (cdr (cdr (cdr (car a))))) )
(define cddddr (lambda (a) (cdr (cdr (cdr (cdr a))))) )

; more primitives
(define newline (lambda () (display "\n")))


(define else #t)  ;; should be a keyword in cond
(define not (lambda (b) (if b #f #t)) ) 
(define zero? (lambda (x) (eq? x 0)) )
(define boolean? (lambda (x) (or (eq? x #t) (eq? x #f)) ))
(define list (lambda args) args)  ; is it this simple?
(define match-taglist (lambda (lst tag)
  (if (not (pair? lst) ) 
      #f
      (eq? (car lst) tag)  )))

(define make-lambda (lambda (form body)
  (cons 'lambda (cons form body))  ))

(define x '(1 2))
(+ . x)
(+ . (1 2 3))
(- . x)
(- . (1 2 3))
(string-ref "abc" 1)
(symbol-ref 'abc 0)
(symbol-ref 'abc 1)
(symbol-ref 'abc 2)
(string-length "abcdefg")
(string-length "ab")
;(exit 1)

; load macros

(load "pc-scheme.mac")

; FIXME: this need to go after all RxRS is defined

;(define null-environment (cdddr (lambda () 12)))  ; (closure <proc> env G)
;null-environment

;; old t and f
;(define #t @1)  ;; define a symbol '#t' to be a special constant 
;(define #f @0)  ;; define a symbol '#f' to be a special constant 
;(define #f '())  ;; Lisp, not scheme
;(define #t '#t)

;; this seems a simple way to represent truth
;(define #t (eq? 1 1))
;(define #f (eq? 1 0))
;(exit 1)
;; simplispic version of equal?
(define _equal? (lambda (a b)
  (if (eq? a b) 
      #t
      (if (and (pair? a) (pair? b) ) 
          (if (_equal? (car a) (car b)) 
              (_equal? (cdr a) (cdr b)) 
              #f  )
          #f  )  )  ))


;;;;;;;;; test harness

; (? expect expression)
; eg (? 3 '(+ 1 2))

(define ?count 0)  ;; count errors

(define (? expect exp)
  (disperr "exp=")
  (printerr exp)
  (printerr '\ ->\ )
  (printerr expect)
  (printerr '\ )
  ;(define result (eval1 exp))  ;; FIXME: this is bad
  (let ((result (eval1 exp)))
    (if (equal? result expect)
      (begin
        (printerr 'pass\n)
        #t  )
      (begin
        (set! ?count (+ ?count 1))
        (printerr 'FAIL\ got\ )
        (printerr result)
        (printerr '\n)
        (if (= ?count 5) (exit) #f )  )  )
  )   
)
(? '#t '(eq? 1 1))
;boolean?
(? '#t '(boolean? #t))
;(exit 1)
(? #t '(boolean? #f))
(? #f '(boolean? '()))
(? #f '(boolean? 0))
(? #f '(boolean? 1))

(define (?a expect exp args)
  (printerr (cons exp args))
  (printerr '\ ->\ )
  (printerr expect)
  (printerr '\ )
  ;(define result (eval1 exp))  ;; FIXME: this is bad
  (let ((result (apply exp args)))
    (if (equal? result expect)
      (begin
        (printerr 'pass)
        (printerr '\n)
        #t  )
      (begin
        (set! ?count (+ ?count 1))
        (printerr 'FAIL\ got\ )
        ;(printerr '\ )
        ;(printerr 'got)
        ;(printerr '\ )
        (printerr result)
        (printerr '\n)
        (if (= ?count 5) (exit) '() )  )  )
  )   
)


(define (?atoms exp)
  (?a '0 exp '(0))
  (?a '1 exp '(1))
  (?a '() exp '(()))
  (?a 'sym exp '(sym))
  (?a "string" exp '("string"))  )

(define (?lists exp)
  (?a '() exp '(()))
  (?a '(1) exp '((1)))
  (?a '(1 2) exp '((1 2)))
  (?a '(1 2 3) exp '((1 2 3)))
  (?a '(1 (2) 3) exp '((1 (2) 3)))
  (?a exp exp (cons exp '()))
    )

(define (?all exp)
  (?atoms exp)
  (?lists exp)  )

;(?all (lambda (a) (car (cons a 0))) )


;(? #t '())
;(exit 1)


;; identity procedure

(define I (lambda (x) x))

;(? I '(I I))
(?all I)

;; force a promise - force is not a special form

(define force (lambda (p) (p))) 
(define d (delay (cons 1 d)))
d
(? '(lambda () (cons 1 d)) '(cadr d))  ;; not evaluated yet
(? '1 '(car (force d)))                ;; now car should be 1
(force d)
(cdr (force d))
(? '(lambda () (cons 1 d)) '(caddr (force d)))  ;; 3rd should be promise
(? '1 '(car (force (cdr (force d)))))          ;; 
;(?all ??  (lambda (x) (force (delay x)))  )


;; stream-cdr is not a special form

(define stream-cdr (lambda (p) (force (cdr p)) ))

;; show n elements of a stream

(define show-stream (lambda (s n)
  (if (eq? n 0)
    '(...)         ;; could not think of a better ending
    (cons (car s)
          (show-stream (stream-cdr s) (- n 1))  )  )))
    
(define ss show-stream)


(define x '(1 2 3))
;x
(set-cdr! x '(a b c))
(? '(1 a b c) 'x)
(set-car! x '(d e f))
(? '((d e f) a b c) 'x)


(? #t '(zero? 0))
(? #f '(zero? 1))
(? #f '(zero? '()))

(define list-tail
  (lambda (x k)
    (if (zero? k)
        x
        (list-tail (cdr x) (- k 1)))))

(define (list-ref a n)
  (if (= n 0)
      (car a)
      (list-ref (cdr a) (- n 1))  )  )

(? 1 '(list-ref '(1 2 3) 0))
(? 2 '(list-ref '(1 2 3) 1))
(? 3 '(list-ref '(1 2 3) 2))

(define make-promise
  (lambda (proc)
    (let ((result-ready? #f)
          (result #f))
      (lambda ()
        (if result-ready?
            result
            (let ((x (proc)))
              (if result-ready?
                  result
                  (begin (set! result-ready? #t)
                         (set! result x)
                         result  )  )))))))

(define x (make-promise (lambda () (+ 2 3))))
x
(force x)
;(exit 1)

;; an expected test

(define (fact n)  ;; test define syntactic sugar macro
  (if (= n 0)
      1
      (* n (fact (- n 1)))  )  )

(? 1 '(fact 0))
(? 1 '(fact 1))
(? 120 '(fact 5))
;;;;;;;;;; tests
           
;; a version of car, cdr and cons using lambda

(define kar (lambda (z) (z (lambda (p q) p))))
(define kdr (lambda (z) (z (lambda (p q) q))))
(define kons (lambda (x y) (lambda (m) (m x y))))

;; another version that is easier to understand but needs if

(define kons2 (lambda (a b) (lambda (m) (if (eq? m 1) a b))))
(define kar2 (lambda (x) (x 1)))
(define kdr2 (lambda (x) (x 2)))

(define car2 (lambda (x) (car x)))


;; test harness - not finished

(define test1 (lambda (pred)
  (if (eval1 pred)
      'pass
      (progn (display "FAIL: ") pred)  )  ))

; is atm a member of an improper list?

(define (member-imp? atm lst)
  (cond ((null? lst) #f)
        ((eq? atm (car lst)) #t)
        ((eq? atm (cdr lst)) #t)
        (else (member-imp? atm (cdr lst)))  ))
        
(? #f '(member-imp? 1 '()))
;(member-imp? 1 '(2 3))
(? #f '(member-imp? 1 '(2 3)))
(? #t '(member-imp? 1 '(1 2 3)))
(? #t '(member-imp? 4 '(1 2 3 . 4)))

(define pr (lambda (a)
  (if (atom? a)
      (print a)
      (progn (print \() (pr (car a)) (pr (cdr a)) (print \)))  )
))

;(define eval-cond (lambda (conds bindings)
;  (if ((eval (car (car conds)) bindings)
;      (eval (car (cdr (car conds))) bindings))
;      (eval-cond (cdr conds) bindings)  )  ))

(? '(1 2 3) '(list 1 2 (+ 1 2)))
(define pc-list2 (lambda args args) )  ; is it this simple?
(define pc-list3 (lambda (first . rest) (cons first rest) ) )




;(define x 2)
;(+ x 3)
;(+ . (list x 3))
;(+ (list x 3))
;;.
(define (_append a b)
  (cond ((null? a) b)
        ((null? b) a)
        (else (cons (car a) (_append (cdr a) b))  )  ))

(define (append . args)
  (cond ((null? args) '())
        ((null? (cdr args)) (car args) )
        (else (_append (car args) (apply append (cdr args))) )  ))


(? '(1 2) '(_append '(1 2)))
;(exit 2)
(? '(1 2) '(_append '(1 2) '()))
(? '(1 2) '(_append '() '(1 2)))
(? '(1 2 3 4) '(_append '(1 2) '(3 4)))
(? '(1 2 . 3) '(_append '(1 2) 3))
(? '(1 2 3 . 4) '(_append '(1 2) '(3 . 4)))

            
(let () (print 1) )
;no good(let* () (print 1) )
(let* ((a 1)) (print a) )
(let* ((a 1) (b (+ a 1))) (print b) )
(let* ((a 1) (b (+ a 2))) (print a) (print b) )

(define (reverse a)
  (if (null? a)
     '()
     (append (reverse (cdr a)) (list (car a)) )  ))
     
(define (gcd a b)
  (if (= b 0) a
      (gcd b (modulo a b))))
      
(? 1 '(gcd 1 2))      
(? 1 '(gcd 1 9))      
(? 9 '(gcd (* 7 9) (* 5 9)))      

(define (gcd-euclid a b)
  (if (= b 0)
      a
      (if (> b a) 
          (gcd-euclid (- b a) a) 
          (gcd-euclid (- a b) b)  )))
(? 1 '(gcd-euclid 1 2))      
(? 1 '(gcd-euclid 1 9))      
(? 9 '(gcd-euclid (* 7 9) (* 5 9)))      

(define (for-each proc list)
  (cond ((null? list) "done")
        (else (proc (car list))
              (for-each proc (cdr list) )  )))
;(? '(1 4 9) '(for-each (lambda (x) (printerr (* x x))) '(1 2 3)))

; another member?
(define (member? x list)
     (cond ((null? list) #f)
           ((not (list? list)) #f)
           ((equal? x (car list)) #t)
           (else   (member? x (cdr list)))  ))
(? #f '(member? 2 '()))
(? #f '(member? 2 '(1 3)))
(? #t '(member? 2 '(1 2 3)))
(? #f '(member? 4 '(1 2 3 . 4)))

;(define ? 1) ; what does redefining this do?

(define (for-each f lst)
	(if (not (null? lst))
    (begin
	    (f (car lst))
	    (for-each f (cdr lst))  )
	  '()  ))

(define (map-list f l)
  (if (null? l)
    '()
     (cons (f (car l)) (map-list f (cdr l)) ) ))

; FIXME: not really map

(define map map-list)

;(for-each (lambda (x) (display x) (display " ")) '(basic for-each test))

;(reverse '(1 (2 3) 4 5 6))

;(begin "ignore" (cons 1 2) "begin result")

;; convert procedures into cps form
;(define (cps-prim f)
; (lambda args
;  (let ((r (reverse args)))
;   ;(print "r=")
;   ;(print r)
;   ((car r) (apply f
;             (reverse (cdr r))))))  )

;(define *& (cps-prim *))
;(define +& (cps-prim +))
;(+& 2 3 (lambda (x) (print x)))

;; make sure set-*! are working

;(define set-test '(2 . 3))
;set-test
;(set-car! set-test 22)
;set-test
;(set-cdr! set-test 33)
;set-test
;(set! set-test '(222 . 333))
;set-test



; FIXME: no map-car

;(define (map f . a*)
;  (let
;    ((carof
;       (lambda (a)
;         (map-car car a)))
;     (cdrof
;       (lambda (a)
;         (map-car cdr a)))
;     (_map
;       (lambda (a* r)
;         (cond ((null? (car a*)) (reverse r))
;           (else (_map (cdrof a*)
;                 (cons (apply f (carof a*)) r)))))))
;    (cond ((null? a*)
;        (bottom '(too few arguments to map)))
;      (else (_map a* '())))))

;(letrec ((x 1) (y 2)) (+ 2 3) (* 2 6))
;(exit 1)

(let ((a 1)) (+ a 11))
(let ((a 1) (b 2)) (+ a b))
(let* ((a 1)) (+ a 11))
(let* ((a 1) (b 2)) (+ a b))

(exit 0)

; keep last

(if (> ?count 0)
  (begin
    (printerr "Error: Toy library failed verification tests\n")
    (printerr 'errors=)
    (printerr ?count)
  )
  (printerr "Note: Toy library passed verification tests\n")
)

